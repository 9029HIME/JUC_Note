以下内容是时隔1年半，再次阅读AQS源码的笔记

1. 非公平锁很不老实啊，在acquire(1)之前就直接插队用cas更改state了，而且就算失败了，在acquire(1)里（nonfairTryAcquire）也不判断前面是否有人排队，又插一次队。单纯的拿锁就插了2次队。

2. 公平也好不公平也好，尝试拿锁前都是判断state的状态。state=0了，代表锁被解开了，此时就是判断是否有人排队（公平），然后和其他线程共同去cas上锁，返回上锁结果。
   如果state不等于0，说明锁已经被占用了，但是总得看看是不是自己占用吧，是的话就再充入一遍，state+1，不是就说明别人还占用着呢，告诉上层方法自己拿锁失败，要去排队了。

3. 在tryAcquire拿锁失败后，公平也好不公平也好都一视同仁了，全都包装成Node往队尾里插。但是插入队列前要想想，有没有可能队列还没生成？因为只有1个线程持锁的情况下是不会生成队列的。所以当队列没生成时，入队代码里会通过enq()创建队列。
   即使队列已经成圣了，可是很多个节点同时插入会不会有问题呢？毕竟tail指针只有1个，但是待插入的节点有很多个。AQS的做法是：
   1.直接将节点的prev指向tail
   2.用CAS(prev,自己)将tail改为自己
   但是那么多线程，只会有1个线程在2.成功，也就是说其他失败的线程都在1.将prev指向成功线程的prev了：

   ​            node-failed2
   ​               ↓
   head ↔ node1（原tail） ↔ node（成功）
   ​               ↑             
   ​             node-failed1

   这就是AQS里的“尾分叉”现象，别急，对于第1次入队失败的线程，会走到enq()里，也就是说enq()有2种作用：创建队列，或整理尾分叉。

4. enq这里，循环利用得很巧妙，先看一下enq前空队列的情况：

   1. 进入t == null代码块，通过cas给head设置一个哑节点，如果成功了，将tail也指向哑节点。走了这一步后，队列必定会被创建好。此时第一次循环结束。
   2. 开始第二次循环，此时只会走到else分支，else分支代表已经有队列的情况。这里的做法和addWaiter插入节点一样，也会出现尾分叉的情况。
   3. 最巧妙的来了，出现尾分叉代表当前线程的节点插入队列失败了，此时是不会走到return t;这段代码，for循环仍未结束，这时候就会开启第3次循环。
   4. 结合代码可以看到，第3次循环还是会走2.的步骤，再次CAS插入队尾，失败了再次循环，一直反复下去，直到成功插入到队尾，结束循环。当所有线程结束了enq方法后，AQS就不会再有尾分叉的情况。